#include "vulnerability_detector.h"
#include <kernwin.hpp>
#include <name.hpp>
#include <search.hpp>

VulnerabilityDetector::VulnerabilityDetector()
{
}

VulnerabilityDetector::~VulnerabilityDetector()
{
}

bool VulnerabilityDetector::AnalyzeBufferOverflow(ea_t address)
{
    insn_t instruction;
    if (decode_insn(&instruction, address))
    {
        if (instruction.itype == NN_call)
        {
            char functionName[MAXSTR];
            get_func_name(instruction.ops[0].addr, functionName, sizeof(functionName));
            
            qstring functionNameStr(functionName);
            if (functionNameStr.find("strcpy") != qstring::npos ||
                functionNameStr.find("strcat") != qstring::npos ||
                functionNameStr.find("gets") != qstring::npos)
            {
                AddFinding(functionName, "Buffer Overflow", address, 4, 
                          "Unsafe string operation detected");
                return true;
            }
        }
    }
    return false;
}

bool VulnerabilityDetector::AnalyzeUseAfterFree(ea_t address)
{
    const char* useAfterFreePattern = "\x8B\x08\xFF\x51\x00\x8B\xF0\x85\xF6";
    const char* useAfterFreeMask = "xxxx?xxxx";
    
    if (CheckPattern(address, useAfterFreePattern, useAfterFreeMask))
    {
        AddFinding("Unknown", "Use After Free", address, 5,
                  "Potential use after free pattern detected");
        return true;
    }
    return false;
}

bool VulnerabilityDetector::AnalyzeIntegerOverflow(ea_t address)
{
    const char* integerOverflowPattern = "\x0F\xAF\x00\x00\x83\xC8\xFF";
    const char* integerOverflowMask = "xx??xxx";
    
    if (CheckPattern(address, integerOverflowPattern, integerOverflowMask))
    {
        AddFinding("Unknown", "Integer Overflow", address, 3,
                  "Integer overflow pattern detected");
        return true;
    }
    return false;
}

bool VulnerabilityDetector::AnalyzeIOCTLHandler(ea_t address)
{
    segment_t* segment = getseg(address);
    if (segment && segment->type == SEG_CODE)
    {
        insn_t instruction;
        if (decode_insn(&instruction, address))
        {
            if (instruction.itype == NN_mov && instruction.ops[1].type == o_reg)
            {
                char nameBuffer[MAXSTR];
                get_name(instruction.ops[0].addr, nameBuffer, sizeof(nameBuffer));
                
                if (strstr(nameBuffer, "IOCTL") || strstr(nameBuffer, "DeviceControl"))
                {
                    AddFinding("IOCTL_Handler", "IOCTL Security", address, 4,
                              "IOCTL handler detected - requires validation review");
                    return true;
                }
            }
        }
    }
    return false;
}

bool VulnerabilityDetector::AnalyzeUnsafeFunction(ea_t address)
{
    insn_t instruction;
    if (decode_insn(&instruction, address))
    {
        if (instruction.itype == NN_call)
        {
            char functionName[MAXSTR];
            get_func_name(instruction.ops[0].addr, functionName, sizeof(functionName));
            
            for (int i = 0; i < 10; i++)
            {
                if (strstr(functionName, dangerousFunctions[i]))
                {
                    AddFinding(functionName, "Unsafe Function", address, 3,
                              "Potentially unsafe function call detected");
                    return true;
                }
            }
        }
    }
    return false;
}

bool VulnerabilityDetector::CheckPattern(ea_t startAddress, const char* pattern, const char* mask)
{
    ea_t currentAddress = startAddress;
    ea_t endAddress = get_inf_structure().end_ea;
    
    while (currentAddress < endAddress)
    {
        ea_t foundAddress = bin_search(currentAddress, endAddress, 
                                     pattern, NULL, 0, BIN_SEARCH_FORWARD);
        if (foundAddress != BADADDR)
        {
            return true;
        }
        break;
    }
    return false;
}

void VulnerabilityDetector::AddFinding(const char* functionName, const char* vulnType, 
                                     ea_t address, int severity, const char* description)
{
    VulnerabilityResult result;
    result.functionName = functionName;
    result.vulnerabilityType = vulnType;
    result.address = address;
    result.severity = severity;
    result.description = description;
    
    char addressInfo[MAXSTR];
    get_name(address, addressInfo, sizeof(addressInfo));
    result.evidence = addressInfo;
    
    detectionResults.push_back(result);
}

void VulnerabilityDetector::ScanForVulnerabilities()
{
    detectionResults.clear();
    
    ea_t currentAddress = get_inf_structure().start_ea;
    ea_t endAddress = get_inf_structure().end_ea;
    
    msg("Starting vulnerability scan...\n");
    
    while (currentAddress < endAddress)
    {
        AnalyzeBufferOverflow(currentAddress);
        AnalyzeUseAfterFree(currentAddress);
        AnalyzeIntegerOverflow(currentAddress);
        AnalyzeIOCTLHandler(currentAddress);
        AnalyzeUnsafeFunction(currentAddress);
        
        currentAddress = next_head(currentAddress, endAddress);
    }
    
    msg("Vulnerability scan completed. Found %d issues.\n", detectionResults.size());
}

std::vector<VulnerabilityResult> VulnerabilityDetector::GetResults()
{
    return detectionResults;
}
